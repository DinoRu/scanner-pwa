import localforage from 'localforage';

// Configuration de localforage pour utiliser IndexedDB
const scanQueue = localforage.createInstance({
  name: 'didi-scanner',
  storeName: 'scan_queue',
  description: 'Queue de scans en attente de synchronisation'
});

const scanHistory = localforage.createInstance({
  name: 'didi-scanner',
  storeName: 'scan_history',
  description: 'Historique local des scans'
});

// ============================================
// QUEUE DE SYNCHRONISATION
// ============================================

export async function saveToQueue(scanData) {
  try {
    const id = Date.now().toString();
    const scan = {
      id,
      ...scanData,
      queuedAt: new Date().toISOString(),
      synced: false
    };
    
    await scanQueue.setItem(id, scan);
    await saveToHistory(scan);
    
    console.log('Scan ajouté à la queue:', id);
    return scan;
  } catch (error) {
    console.error('Erreur saveToQueue:', error);
    throw error;
  }
}

export async function getQueuedScans() {
  try {
    const scans = [];
    await scanQueue.iterate((value) => {
      if (!value.synced) {
        scans.push(value);
      }
    });
    return scans.sort((a, b) => 
      new Date(b.queuedAt) - new Date(a.queuedAt)
    );
  } catch (error) {
    console.error('Erreur getQueuedScans:', error);
    return [];
  }
}

export async function removeFromQueue(scanId) {
  try {
    await scanQueue.removeItem(scanId);
    console.log('Scan retiré de la queue:', scanId);
  } catch (error) {
    console.error('Erreur removeFromQueue:', error);
  }
}

export async function markAsSynced(scanId) {
  try {
    const scan = await scanQueue.getItem(scanId);
    if (scan) {
      scan.synced = true;
      scan.syncedAt = new Date().toISOString();
      await scanQueue.setItem(scanId, scan);
    }
  } catch (error) {
    console.error('Erreur markAsSynced:', error);
  }
}

export async function clearQueue() {
  try {
    await scanQueue.clear();
    console.log('Queue vidée');
  } catch (error) {
    console.error('Erreur clearQueue:', error);
  }
}

// ============================================
// HISTORIQUE LOCAL
// ============================================

export async function saveToHistory(scanData) {
  try {
    const id = scanData.id || Date.now().toString();
    await scanHistory.setItem(id, {
      id,
      ...scanData,
      savedAt: new Date().toISOString()
    });
    
    // Limiter l historique à 200 entrées
    await limitHistory(200);
  } catch (error) {
    console.error('Erreur saveToHistory:', error);
  }
}

export async function getHistory(limit = 50) {
  try {
    const scans = [];
    await scanHistory.iterate((value) => {
      scans.push(value);
    });
    
    return scans
      .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
      .slice(0, limit);
  } catch (error) {
    console.error('Erreur getHistory:', error);
    return [];
  }
}

export async function clearHistory() {
  try {
    await scanHistory.clear();
    console.log('Historique vidé');
  } catch (error) {
    console.error('Erreur clearHistory:', error);
  }
}

async function limitHistory(maxEntries) {
  try {
    const scans = [];
    await scanHistory.iterate((value, key) => {
      scans.push({ key, timestamp: value.timestamp });
    });
    
    if (scans.length > maxEntries) {
      // Trier par date et supprimer les plus anciens
      scans.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
      const toDelete = scans.slice(0, scans.length - maxEntries);
      
      for (const scan of toDelete) {
        await scanHistory.removeItem(scan.key);
      }
    }
  } catch (error) {
    console.error('Erreur limitHistory:', error);
  }
}

// ============================================
// STATISTIQUES LOCALES
// ============================================

export async function getLocalStats() {
  try {
    const scans = await getHistory(1000);
    const today = new Date().toDateString();
    
    const todayScans = scans.filter(s => 
      new Date(s.timestamp).toDateString() === today
    );
    
    return {
      total: scans.length,
      today: todayScans.length,
      pending: (await getQueuedScans()).length
    };
  } catch (error) {
    console.error('Erreur getLocalStats:', error);
    return { total: 0, today: 0, pending: 0 };
  }
}

// ============================================
// UTILITAIRES
// ============================================

export async function getStorageInfo() {
  try {
    const queueSize = await scanQueue.length();
    const historySize = await scanHistory.length();
    
    return {
      queueSize,
      historySize,
      total: queueSize + historySize
    };
  } catch (error) {
    console.error('Erreur getStorageInfo:', error);
    return { queueSize: 0, historySize: 0, total: 0 };
  }
}

export async function clearAllData() {
  try {
    await clearQueue();
    await clearHistory();
    console.log('Toutes les données locales supprimées');
  } catch (error) {
    console.error('Erreur clearAllData:', error);
  }
}